import {describe,beforeEach, it, expect, vi} from  'vitest';
import * as bootbox from '../src/bootbox';
import * as bootstrap from 'bootstrap';
import Options from '../src/interfaces/Options';

let options: Options;
let callback: any;
let hidden: any;

let dialog: HTMLElement | null;
let button: HTMLElement | null;

// Generated by CoffeeScript 1.7.1
describe('bootbox.confirm',
	() => {
		'use strict';
		describe('basic usage tests',
			() => {
				describe('with one argument',
					() => {

						describe('where the argument is not an object',
							() => {
								it('throws an error',
									() => {
										expect(() => bootbox.confirm('Are you sure?'))
											.toThrowError(/confirm requires a callback/);
									});
							});

						describe('where the argument is an object',
							() => {
								beforeEach(() => {
									options = {};
								});


								describe('with a message property',
									() => {
										beforeEach(() => {
											options.message = 'Are you sure?';
										});
										it('throws an error requiring a callback',
											() => {
												expect(() => bootbox.confirm('Are you sure?', options))
													.toThrowError(/confirm requires a callback/);
											});
									});


								describe('with a callback property',
									() => {
										describe('where the callback is not a function',
											() => {
												beforeEach(() => {
													options.callback = 'Are you sure?';
												});
												it('throws an error requiring a callback',
													() => {
														expect(() => bootbox.confirm('Are you sure?', options))
															.toThrowError(/confirm requires a callback/);
													});
											});

										describe('where the callback is a function',
											() => {
												beforeEach(() => {
													options.callback = () => true;
												});
												it('throws an error requiring a message',
													() => {
														expect(() => bootbox.confirm(options))
															.toThrowError(
																/"message" option must not be null or an empty string./);
													});
											});
									});

								describe('with a message and a callback',
									() => {
										beforeEach(() => {
											options = {
												callback() {
													return true;
												},
												message: 'Are you sure?'
											};

											dialog = bootbox.confirm(options);

										});

										it('does not throw an error',
											() => {
												vi.spyOn(console, 'warn');
												expect(() => bootbox.confirm(options)).not.throw(Error);
											});
										it('creates a dialog object',
											() => {
												expect(bootstrap.Modal.getInstance(dialog!)).to.be.an('object');
											});
										it('adds the correct button labels',
											() => {
												expect(dialog?.querySelector('.btn:first-child')?.textContent).to
													.equal('Cancel');
												expect(dialog?.querySelector('.btn:last-child')?.textContent).to
													.equal('OK');
											});
										it('adds the correct button classes',
											() => {
												expect(dialog?.querySelector('.btn:first-child')?.classList)
													.toContain('btn-secondary');
												expect(dialog?.querySelector('.btn:first-child')?.classList)
													.toContain('bootbox-cancel');

												expect(dialog?.querySelector('.btn:last-child')?.classList)
													.toContain('btn-primary');
												expect(dialog?.querySelector('.btn:last-child')?.classList)
													.toContain('bootbox-accept');
											});
									});
							});
					});

				describe('with two arguments',
					() => {
						describe('where the second argument is not a function',
							() => {
								it('throws an error requiring a callback',
									() => {
										expect(() => bootbox.confirm('Are you sure?', 'callback here'))
											.toThrowError(/confirm requires a callback/);
									});
							});

						describe('where the second argument is a function',
							() => {
								beforeEach(() => {
									dialog = bootbox.confirm('Are you sure?',
										() => {
											return true;
										});
								});
								it('creates a dialog object',
									() => {
										expect(bootstrap.Modal.getInstance(dialog)).to.be.an('object');
									});
								it('applies the bootbox-confirm class to the dialog',
									() => {
										expect(dialog?.classList).toContain('bootbox-confirm');
									});
								it('adds the correct button labels',
									() => {
										expect(dialog?.querySelector<HTMLElement>('.btn:first-child')?.textContent).to
											.equal('Cancel');
										expect(dialog?.querySelector<HTMLElement>('.btn:last-child')?.textContent).to
											.equal('OK');
									});
								it('adds the correct button classes',
									() => {
										expect(dialog?.querySelector<HTMLElement>('.btn:first-child')?.classList)
											.toContain('btn-secondary');
										expect(dialog?.querySelector<HTMLElement>('.btn:first-child')?.classList)
											.toContain('bootbox-cancel');

										expect(dialog?.querySelector<HTMLElement>('.btn:last-child')?.classList)
											.toContain('btn-primary');
										expect(dialog?.querySelector<HTMLElement>('.btn:last-child')?.classList)
											.toContain('bootbox-accept');
									});

								it('shows the dialog',
									() => {
										var isVisible = bootstrap.Modal.getInstance(dialog)?._isShown;
										expect(isVisible).to.true;
									});
							});

					});
			});

		describe('configuration options tests',
			() => {
				beforeEach(() => {
					options = {
						message: 'Are you sure?',
						callback() {
							return true;
						}
					};

				});

				describe('with a custom cancel button',
					() => {
						beforeEach(() => {
							options = {
								message: 'Are you sure?',
								callback() {
									return true;
								}
							};
							options.buttons = {
								cancel: {
									label: 'Custom cancel',
									className: 'btn-danger',
								}
							};
							dialog = bootbox.confirm(options);
							return button = dialog.querySelector('.btn:first-child');
						});
						it('adds the correct cancel button',
							() => {
								expect(button?.textContent).to.equal('Custom cancel');
								expect(button?.classList).toContain('btn-danger');
							});
					});

				describe('with a custom confirm button',
					() => {
						beforeEach(() => {
							options.buttons = {
								confirm: {
									label: 'Custom confirm',
									className: 'btn-warning'
								}
							};
							var dialog = bootbox.confirm(options);
							button = dialog.querySelector('.btn:first-child');
						});
						it('adds the correct confirm button',
							() => {
								expect(button?.textContent).to.equal('Custom confirm');
								expect(button?.classList).toContain('btn-warning');
							});
					});

				describe('with an unrecognised button key',
					() => {
						beforeEach(() => {
							options.buttons = {
								'Bad key': {
									label: 'Custom confirm',
									className: 'btn-warning'
								}
							};
						});
						it('throws an error',
							() => {
								expect(() => bootbox.confirm(options))
									.toThrowError('button key "Bad key" is not allowed (options are cancel confirm)');
							});
					});
			});

		describe('callback tests',
			() => {
				describe('with a simple callback',
					() => {
						beforeEach(() => {
							callback = vi.fn(() => true);
							dialog = bootbox.confirm({
								message: 'Are you sure?',
								callback: callback
							});

							const modalInstance = bootstrap.Modal.getInstance(dialog);
							hidden = vi.spyOn(modalInstance, 'hide');
						});

						describe('when dismissing the dialog by clicking OK',
							() => {
								beforeEach(() => {
									dialog?.querySelector<HTMLElement>('.bootbox-accept')?.click();
								});
								it('should invoke the callback',
									() => {
										expect(callback).toHaveBeenCalled();
									});
								it('should pass the dialog as "this"',
									() => {
										expect(callback.mock.instances[0]).to.equal(dialog);
									});
								it('with the correct value',
									() => {
										expect(callback).toHaveBeenCalledWith(true);
									});
								it('should hide the modal',
									() => {
										expect(hidden).toHaveBeenCalledWith();
									});
							});

						describe('when dismissing the dialog by clicking Cancel',
							() => {
								beforeEach(() => {
									return dialog?.querySelector<HTMLElement>('.bootbox-cancel')?.click();
								});
								it('should invoke the callback',
									() => {
										expect(callback).toHaveBeenCalled();
									});
								it('should pass the dialog as "this"',
									() => {
										expect(callback.mock.instances[0]).to.equal(dialog);
									});
								it('with the correct value',
									() => {
										expect(callback).toHaveBeenCalled();
									});
								it('should hide the modal',
									() => {
										expect(hidden).toHaveBeenCalled();
									});
							});

						describe('when triggering the escape event',
							() => {
								beforeEach(() => {
									return dialog?.dispatchEvent(new Event('escape.close.bb'));
								});
								it('should invoke the callback',
									() => {
										expect(callback).toHaveBeenCalled();
									});
								it('should pass the dialog as "this"',
									() => {
										expect(callback.mock.instances[0]).to.equal(dialog);
									});
								it('with the correct value',
									() => {
										expect(callback).toHaveBeenCalled();
									});
								it('should hide the modal',
									() => {
										expect(hidden).toHaveBeenCalledWith();
									});
							});
					});

				describe('with a callback which returns false',
					() => {
						beforeEach(() => {
							callback = vi.fn(() => false);
							dialog = bootbox.confirm({
								message: 'Are you sure?',
								callback: callback
							});

							const modalInstance = bootstrap.Modal.getInstance(dialog);

							hidden = vi.spyOn(modalInstance, 'hide');
						});

						describe('when dismissing the dialog by clicking OK',
							() => {
								beforeEach(() => {
									return dialog?.querySelector<HTMLElement>('.bootbox-accept')?.click();
								});
								it('should invoke the callback',
									() => {
										expect(callback).toHaveBeenCalled();
									});
								it('should pass the dialog as "this"',
									() => {
										expect(callback.mock.instances[0]).to.equal(dialog);
									});
								it('with the correct value',
									() => {
										expect(callback).toHaveBeenCalledWith(true);
									});
								it('should not hide the modal',
									() => {
										expect(hidden).not.toHaveBeenCalled();
									});
							});

						describe('when dismissing the dialog by clicking Cancel',
							() => {
								beforeEach(() => {
									return dialog?.querySelector<HTMLElement>('.bootbox-cancel')?.click();
								});
								it('should invoke the callback',
									() => {
										expect(callback).toHaveBeenCalled();
									});
								it('should pass the dialog as "this"',
									() => {
										expect(callback.mock.instances[0]).to.equal(dialog);
									});
								it('with the correct value',
									() => {
										expect(callback).toHaveBeenCalled();
									});
								it('should not hide the modal',
									() => {
										expect(hidden).not.toHaveBeenCalled();
									});
							});

						describe('when triggering the escape event',
							() => {
								beforeEach(() => {
									dialog?.dispatchEvent(new CustomEvent('escape.close.bb'));
								});
								it('should invoke the callback',
									() => {
										expect(callback).toHaveBeenCalled();
									});
								it('should pass the dialog as "this"',
									() => {
										expect(callback.mock.instances[0]).to.equal(dialog);
									});
								it('with the correct value',
									() => {
										expect(callback).toHaveBeenCalled();
									});
								it('should not hide the modal',
									() => {
										expect(hidden).not.toHaveBeenCalled();
									});
							});

					});
			});
	});
